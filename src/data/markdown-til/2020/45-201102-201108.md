- Dependency Inversion Principle
  - One of the principle of SOLID by Robert Martin.
  - The principle states:
    - High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g. interfaces)
    - Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.
  - Inversion of Control(IoC) > Dependency Inversion Principle
    - Library and Framework are the example of Inversion of Control. When you use library, you call library functions from your code. But when you use framework, it's the framework that calls your codes.
    - It's also called Hollywood Principle. "Don't call us, we'll call you."
  - Dependency Injection is one of the methods to embody Dependency Inversion Principle.
  - ref: [https://justhackem.wordpress.com/2016/05/13/dependency-inversion-terms/](https://justhackem.wordpress.com/2016/05/13/dependency-inversion-terms/)
    - I think this is a very good article in that it clearly articulates the difference among concepts that are easily recognized as similar. I should ALWAYS try to understand concepts 100% exactly not vaguely.
- Require vs Import
  - When you import only specific module to use. it's better in terms of efficiency with the help of webpack's tree shaking. I didn't know there's something called tree shaking.
- Testing
  - Articles about testing in React official site is the good resource (as always) to take first step to react testing.
    [https://reactjs.org/docs/testing.html#gatsby-focus-wrapper](https://reactjs.org/docs/testing.html#gatsby-focus-wrapper) - Two ways to test React components. - Rendering component trees - to check simply input and output - Running a complete app(E2E) - to check in realistic browser environment.
  - Guide to testing
    - Rendering : Testing whether a component renders correctly for given props.
    - Data Fetching : By fetching fake data, you can check flow of code including API calls more faster.
    - Mocking Module : Some modules might not work well inside a testing environment, or may not be as essential to the test itself. Then you can mock these out.
    - Events : Dispatch real DOM events on DOM elements. ex) new MouseEvent("click", { bubbles: true})
    - and so on: Timers(to emulate user action), Snapshot Testing, Multiple Renders.
  - When writing UI tests, tasks like rendering, user events, or data fetching can be considered as "units" of interaction with a user interface.
    - Jest vs Mocha
      - Do you want to start testing simple without the extra setup and configuration up front? Jest. Better for smaller project.
      - Do you want to have complete control of testing framework? Mocha. Better for huge project. It is one of the most flexible JavaScript testing libraries. It allows various options requiring some additional setup and configuration.
  - TOAST UI Blog Article : Pragmatic Front-End Testing Strategies (1)
    - [https://ui.toast.com/weekly-pick/en_20190405](https://ui.toast.com/weekly-pick/en_20190405)
    - It's helpful because it is:
      - providing standard of "Good Test"
        - "The second category dictates that for good tests, “altering the implementation detail should not break the code.” Hence, the tests should validate “what” the code does instead of “how” the code does."
      - showing realistic and pragmatic view on testing :
        - "While it may seem anticlimactic, in my opinion, no technology has yet to triumph over the “developer’s eyes” when it comes to visual testing."
  - [https://www.chromatic.com/blog/visual-testing-the-pragmatic-way-to-test-uis/](https://www.chromatic.com/blog/visual-testing-the-pragmatic-way-to-test-uis/)
    - How snapshots are taken? either by comparing HTML output, or by taking rendered screenshots and comparing them pixel by pixel.
    - Problem
      - Snapshot testing is useful, but ultimately suffers from the same brittleness as all other automated UI tests, in that tests must be constantly updated as minor details (that may not ultimately matter to the user) trigger the test to fail. Ultimately a developer must check a failing test to confirm if it is a false positive.
      - Snapshot testing entails an admission of defeat in capturing the essential details of a component: instead we capture them all.
    - Solution
      - Using a comonent explorer. Human defines test states, and use the explorer to choose a state and a component and see it on the screen. It's kind of munual test. but much easier.
  - [https://velopert.com/3587](https://velopert.com/3587)
    - With component test,
      1. 특정 props 에 따라 컴포넌트가 크래쉬 없이 잘 렌더링이 되는지 확인
      2. 이전에 렌더링했던 결과와, 지금 렌더링한 결과가 일치하는지 확인
      3. 특정 DOM 이벤트를 시뮬레이트 하여, 원하는 변화가 제대로 발생하는지 확인
      4. 렌더링된 결과물을 *이미지* 로 저장을 하여 픽셀을 하나하나 확인해서 모두 일치하는지 확인
      - For 1 ~ 3: Use Jest / Enzyme and so on, For 4: Use storybook/cypress
  - Testing with redux-saga
    - Comparison among several redux-saga testing libraries: [https://blog.scottlogic.com/2018/01/16/evaluating-redux-saga-test-libraries.html](https://blog.scottlogic.com/2018/01/16/evaluating-redux-saga-test-libraries.html)
- git fetch —prune
  - Use if when you want to remove any remote-tracking references that no longer exist on the remote.
